! This file was automatically generated by SWIG (http://www.swig.org).
! Version 4.0.0
!
! Do not make changes to this file unless you know what you are doing--modify
! the SWIG interface file instead.
module datatransferkit
 use, intrinsic :: ISO_C_BINDING
 implicit none
 private

 ! PUBLIC METHODS AND TYPES

type, bind(C) :: SwigArrayWrapper
  type(C_PTR), public :: data = C_NULL_PTR
  integer(C_SIZE_T), public :: size = 0
end type

 public :: DTK_version
 public :: DTK_git_commit_hash
 public :: DTK_CellTopology, DTK_TRI_3, DTK_TRI_6, DTK_QUAD_4, DTK_QUAD_9, DTK_TET_4, DTK_TET_10, DTK_TET_11, DTK_HEX_8, &
    DTK_HEX_20, DTK_HEX_27, DTK_PYRAMID_5, DTK_PYRAMID_13, DTK_WEDGE_6, DTK_WEDGE_15, DTK_WEDGE_18, DTK_N_TOPO
 public :: DTK_MemorySpace, DTK_HOST_SPACE, DTK_CUDAUVM_SPACE
 public :: DTK_ExecutionSpace, DTK_SERIAL, DTK_OPENMP, DTK_CUDA
 public :: DTK_create_user_application
 public :: DTK_is_valid_user_application
 public :: DTK_destroy_user_application
 public :: DTK_create_map
 public :: DTK_is_valid_map
 public :: DTK_apply_map
 public :: DTK_destroy_map
 public :: DTK_initialize
 public :: DTK_initialize_cmd
 public :: DTK_is_initialized
 public :: DTK_finalize
 public :: DTK_Error, DTK_SUCCESS, DTK_INVALID_HANDLE, DTK_UNINITIALIZED, DTK_UNKNOWN
 public :: DTK_FunctionType, DTK_NODE_LIST_SIZE_FUNCTION, DTK_NODE_LIST_DATA_FUNCTION, DTK_BOUNDING_VOLUME_LIST_SIZE_FUNCTION, &
    DTK_BOUNDING_VOLUME_LIST_DATA_FUNCTION, DTK_POLYHEDRON_LIST_SIZE_FUNCTION, DTK_POLYHEDRON_LIST_DATA_FUNCTION, &
    DTK_CELL_LIST_SIZE_FUNCTION, DTK_CELL_LIST_DATA_FUNCTION, DTK_BOUNDARY_SIZE_FUNCTION, DTK_BOUNDARY_DATA_FUNCTION, &
    DTK_ADJACENCY_LIST_SIZE_FUNCTION, DTK_ADJACENCY_LIST_DATA_FUNCTION, DTK_DOF_MAP_SIZE_FUNCTION, DTK_DOF_MAP_DATA_FUNCTION, &
    DTK_MIXED_TOPOLOGY_DOF_MAP_SIZE_FUNCTION, DTK_MIXED_TOPOLOGY_DOF_MAP_DATA_FUNCTION, DTK_FIELD_SIZE_FUNCTION, &
    DTK_PULL_FIELD_DATA_FUNCTION, DTK_PUSH_FIELD_DATA_FUNCTION, DTK_EVALUATE_FIELD_FUNCTION
 public :: DTK_set_user_function

 ! PARAMETERS
 enum, bind(c)
  enumerator :: DTK_CellTopology = -1
  enumerator :: DTK_TRI_3 = 0
  enumerator :: DTK_TRI_6 = DTK_TRI_3 + 1
  enumerator :: DTK_QUAD_4 = DTK_TRI_6 + 1
  enumerator :: DTK_QUAD_9 = DTK_QUAD_4 + 1
  enumerator :: DTK_TET_4 = DTK_QUAD_9 + 1
  enumerator :: DTK_TET_10 = DTK_TET_4 + 1
  enumerator :: DTK_TET_11 = DTK_TET_10 + 1
  enumerator :: DTK_HEX_8 = DTK_TET_11 + 1
  enumerator :: DTK_HEX_20 = DTK_HEX_8 + 1
  enumerator :: DTK_HEX_27 = DTK_HEX_20 + 1
  enumerator :: DTK_PYRAMID_5 = DTK_HEX_27 + 1
  enumerator :: DTK_PYRAMID_13 = DTK_PYRAMID_5 + 1
  enumerator :: DTK_WEDGE_6 = DTK_PYRAMID_13 + 1
  enumerator :: DTK_WEDGE_15 = DTK_WEDGE_6 + 1
  enumerator :: DTK_WEDGE_18 = DTK_WEDGE_15 + 1
  enumerator :: DTK_N_TOPO = DTK_WEDGE_18 + 1
 end enum
 enum, bind(c)
  enumerator :: DTK_MemorySpace = -1
  enumerator :: DTK_HOST_SPACE = 0
  enumerator :: DTK_CUDAUVM_SPACE = DTK_HOST_SPACE + 1
 end enum
 enum, bind(c)
  enumerator :: DTK_ExecutionSpace = -1
  enumerator :: DTK_SERIAL = 0
  enumerator :: DTK_OPENMP = DTK_SERIAL + 1
  enumerator :: DTK_CUDA = DTK_OPENMP + 1
 end enum
 enum, bind(c)
  enumerator :: DTK_Error = -1
  enumerator :: DTK_SUCCESS = 0
  enumerator :: DTK_INVALID_HANDLE = -1
  enumerator :: DTK_UNINITIALIZED = -2
  enumerator :: DTK_UNKNOWN = -99
 end enum
 enum, bind(c)
  enumerator :: DTK_FunctionType = -1
  enumerator :: DTK_NODE_LIST_SIZE_FUNCTION = 0
  enumerator :: DTK_NODE_LIST_DATA_FUNCTION = DTK_NODE_LIST_SIZE_FUNCTION + 1
  enumerator :: DTK_BOUNDING_VOLUME_LIST_SIZE_FUNCTION = DTK_NODE_LIST_DATA_FUNCTION + 1
  enumerator :: DTK_BOUNDING_VOLUME_LIST_DATA_FUNCTION = DTK_BOUNDING_VOLUME_LIST_SIZE_FUNCTION + 1
  enumerator :: DTK_POLYHEDRON_LIST_SIZE_FUNCTION = DTK_BOUNDING_VOLUME_LIST_DATA_FUNCTION + 1
  enumerator :: DTK_POLYHEDRON_LIST_DATA_FUNCTION = DTK_POLYHEDRON_LIST_SIZE_FUNCTION + 1
  enumerator :: DTK_CELL_LIST_SIZE_FUNCTION = DTK_POLYHEDRON_LIST_DATA_FUNCTION + 1
  enumerator :: DTK_CELL_LIST_DATA_FUNCTION = DTK_CELL_LIST_SIZE_FUNCTION + 1
  enumerator :: DTK_BOUNDARY_SIZE_FUNCTION = DTK_CELL_LIST_DATA_FUNCTION + 1
  enumerator :: DTK_BOUNDARY_DATA_FUNCTION = DTK_BOUNDARY_SIZE_FUNCTION + 1
  enumerator :: DTK_ADJACENCY_LIST_SIZE_FUNCTION = DTK_BOUNDARY_DATA_FUNCTION + 1
  enumerator :: DTK_ADJACENCY_LIST_DATA_FUNCTION = DTK_ADJACENCY_LIST_SIZE_FUNCTION + 1
  enumerator :: DTK_DOF_MAP_SIZE_FUNCTION = DTK_ADJACENCY_LIST_DATA_FUNCTION + 1
  enumerator :: DTK_DOF_MAP_DATA_FUNCTION = DTK_DOF_MAP_SIZE_FUNCTION + 1
  enumerator :: DTK_MIXED_TOPOLOGY_DOF_MAP_SIZE_FUNCTION = DTK_DOF_MAP_DATA_FUNCTION + 1
  enumerator :: DTK_MIXED_TOPOLOGY_DOF_MAP_DATA_FUNCTION = DTK_MIXED_TOPOLOGY_DOF_MAP_SIZE_FUNCTION + 1
  enumerator :: DTK_FIELD_SIZE_FUNCTION = DTK_MIXED_TOPOLOGY_DOF_MAP_DATA_FUNCTION + 1
  enumerator :: DTK_PULL_FIELD_DATA_FUNCTION = DTK_FIELD_SIZE_FUNCTION + 1
  enumerator :: DTK_PUSH_FIELD_DATA_FUNCTION = DTK_PULL_FIELD_DATA_FUNCTION + 1
  enumerator :: DTK_EVALUATE_FIELD_FUNCTION = DTK_PUSH_FIELD_DATA_FUNCTION + 1
 end enum

 ! WRAPPER DECLARATIONS
 interface
function swigc_DTK_version() &
bind(C, name="_wrap_DTK_version") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
import :: SwigArrayWrapper
type(SwigArrayWrapper) :: fresult
end function


subroutine SWIG_free(ptr) &
  bind(C, name="free")
 use, intrinsic :: ISO_C_BINDING
 type(C_PTR), value :: ptr
end subroutine

function swigc_DTK_git_commit_hash() &
bind(C, name="_wrap_DTK_git_commit_hash") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
import :: SwigArrayWrapper
type(SwigArrayWrapper) :: fresult
end function

function DTK_create_user_application(space) &
bind(C, name="DTK_createUserApplication") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: space
type(C_PTR) :: fresult
end function

function DTK_is_valid_user_application(handle) &
bind(C, name="DTK_isValidUserApplication") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: handle
logical(C_BOOL) :: fresult
end function

subroutine DTK_destroy_user_application(handle) &
bind(C, name="DTK_destroyUserApplication")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: handle
end subroutine

function DTK_create_map(space, comm, source, target, options) &
bind(C, name="DTK_createMap") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
integer(C_INT), value :: space
integer(C_INT), value :: comm
type(C_PTR), value :: source
type(C_PTR), value :: target
character(C_CHAR), intent(in) :: options
type(C_PTR) :: fresult
end function

function DTK_is_valid_map(handle) &
bind(C, name="DTK_isValidMap") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: handle
logical(C_BOOL) :: fresult
end function

subroutine DTK_apply_map(handle, source_field, target_field) &
bind(C, name="DTK_applyMap")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: handle
character(C_CHAR), intent(in) :: source_field
character(C_CHAR), intent(in) :: target_field
end subroutine

subroutine DTK_destroy_map(handle) &
bind(C, name="DTK_destroyMap")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: handle
end subroutine

subroutine DTK_initialize() &
bind(C, name="DTK_initialize")
use, intrinsic :: ISO_C_BINDING
end subroutine

subroutine DTK_initialize_cmd(argc, argv) &
bind(C, name="DTK_initializeCmd")
use, intrinsic :: ISO_C_BINDING
integer(C_INT) :: argc
type(C_PTR), value :: argv
end subroutine

function DTK_is_initialized() &
bind(C, name="DTK_isInitialized") &
result(fresult)
use, intrinsic :: ISO_C_BINDING
logical(C_BOOL) :: fresult
end function

subroutine DTK_finalize() &
bind(C, name="DTK_finalize")
use, intrinsic :: ISO_C_BINDING
end subroutine

subroutine DTK_set_user_function(handle, type, f, user_data) &
bind(C, name="DTK_setUserFunction")
use, intrinsic :: ISO_C_BINDING
type(C_PTR), value :: handle
integer(C_INT), value :: type
type(C_FUNPTR), value :: f
type(C_PTR), value :: user_data
end subroutine

 end interface


contains
 ! FORTRAN PROXY CODE

subroutine SWIG_chararray_to_string(wrap, string)
  use, intrinsic :: ISO_C_BINDING
  type(SwigArrayWrapper), intent(IN) :: wrap
  character(kind=C_CHAR, len=:), allocatable, intent(OUT) :: string
  character(kind=C_CHAR), dimension(:), pointer :: chars
  integer(kind=C_SIZE_T) :: i
  call c_f_pointer(wrap%data, chars, [wrap%size])
  allocate(character(kind=C_CHAR, len=wrap%size) :: string)
  do i=1, wrap%size
    string(i:i) = chars(i)
  enddo
end subroutine

function DTK_version() &
result(swig_result)
use, intrinsic :: ISO_C_BINDING
character(kind=C_CHAR, len=:), allocatable :: swig_result
type(SwigArrayWrapper) :: fresult

fresult = swigc_DTK_version()
call SWIG_chararray_to_string(fresult, swig_result)
call SWIG_free(fresult%data)
end function

function DTK_git_commit_hash() &
result(swig_result)
use, intrinsic :: ISO_C_BINDING
character(kind=C_CHAR, len=:), allocatable :: swig_result
type(SwigArrayWrapper) :: fresult

fresult = swigc_DTK_git_commit_hash()
call SWIG_chararray_to_string(fresult, swig_result)
call SWIG_free(fresult%data)
end function


end module
